# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T11:09:51+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class AMITypes(Enum):
    AL2_x86_64 = 'AL2_x86_64'
    AL2_x86_64_GPU = 'AL2_x86_64_GPU'
    AL2_ARM_64 = 'AL2_ARM_64'
    CUSTOM = 'CUSTOM'
    BOTTLEROCKET_ARM_64 = 'BOTTLEROCKET_ARM_64'
    BOTTLEROCKET_x86_64 = 'BOTTLEROCKET_x86_64'
    BOTTLEROCKET_ARM_64_NVIDIA = 'BOTTLEROCKET_ARM_64_NVIDIA'
    BOTTLEROCKET_x86_64_NVIDIA = 'BOTTLEROCKET_x86_64_NVIDIA'
    WINDOWS_CORE_2019_x86_64 = 'WINDOWS_CORE_2019_x86_64'
    WINDOWS_FULL_2019_x86_64 = 'WINDOWS_FULL_2019_x86_64'
    WINDOWS_CORE_2022_x86_64 = 'WINDOWS_CORE_2022_x86_64'
    WINDOWS_FULL_2022_x86_64 = 'WINDOWS_FULL_2022_x86_64'


class AccessDeniedException(RootModel[Any]):
    root: Any


class AddonIssueCode(Enum):
    AccessDenied = 'AccessDenied'
    InternalFailure = 'InternalFailure'
    ClusterUnreachable = 'ClusterUnreachable'
    InsufficientNumberOfReplicas = 'InsufficientNumberOfReplicas'
    ConfigurationConflict = 'ConfigurationConflict'
    AdmissionRequestDenied = 'AdmissionRequestDenied'
    UnsupportedAddonModification = 'UnsupportedAddonModification'
    K8sResourceNotFound = 'K8sResourceNotFound'


class AddonStatus(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    CREATE_FAILED = 'CREATE_FAILED'
    UPDATING = 'UPDATING'
    DELETING = 'DELETING'
    DELETE_FAILED = 'DELETE_FAILED'
    DEGRADED = 'DEGRADED'
    UPDATE_FAILED = 'UPDATE_FAILED'


class BadRequestException(RootModel[Any]):
    root: Any


class Boolean(RootModel[bool]):
    root: bool


class BoxedBoolean(RootModel[bool]):
    root: bool


class BoxedInteger(RootModel[int]):
    root: int


class Capacity(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class CapacityTypes(Enum):
    ON_DEMAND = 'ON_DEMAND'
    SPOT = 'SPOT'


class ClientException(RootModel[Any]):
    root: Any


class ClusterIssueCode(Enum):
    AccessDenied = 'AccessDenied'
    ClusterUnreachable = 'ClusterUnreachable'
    ConfigurationConflict = 'ConfigurationConflict'
    InternalFailure = 'InternalFailure'
    ResourceLimitExceeded = 'ResourceLimitExceeded'
    ResourceNotFound = 'ResourceNotFound'


class ClusterName(
    RootModel[
        constr(pattern=r'^[0-9A-Za-z][A-Za-z0-9\-_]*', min_length=1, max_length=100)
    ]
):
    root: constr(pattern=r'^[0-9A-Za-z][A-Za-z0-9\-_]*', min_length=1, max_length=100)


class ClusterStatus(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    DELETING = 'DELETING'
    FAILED = 'FAILED'
    UPDATING = 'UPDATING'
    PENDING = 'PENDING'


class ConnectorConfigProvider(Enum):
    EKS_ANYWHERE = 'EKS_ANYWHERE'
    ANTHOS = 'ANTHOS'
    GKE = 'GKE'
    AKS = 'AKS'
    OPENSHIFT = 'OPENSHIFT'
    TANZU = 'TANZU'
    RANCHER = 'RANCHER'
    EC2 = 'EC2'
    OTHER = 'OTHER'


class DeleteAddonRequest(BaseModel):
    pass


class DeleteClusterRequest(BaseModel):
    pass


class DeleteFargateProfileRequest(BaseModel):
    pass


class DeleteNodegroupRequest(BaseModel):
    pass


class DeregisterClusterRequest(BaseModel):
    pass


class DescribeAddonConfigurationRequest(BaseModel):
    pass


class DescribeAddonRequest(BaseModel):
    pass


class DescribeAddonVersionsRequest(BaseModel):
    pass


class DescribeAddonVersionsRequestMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class DescribeClusterRequest(BaseModel):
    pass


class DescribeFargateProfileRequest(BaseModel):
    pass


class DescribeNodegroupRequest(BaseModel):
    pass


class DescribeUpdateRequest(BaseModel):
    pass


class ErrorCode(Enum):
    SubnetNotFound = 'SubnetNotFound'
    SecurityGroupNotFound = 'SecurityGroupNotFound'
    EniLimitReached = 'EniLimitReached'
    IpNotAvailable = 'IpNotAvailable'
    AccessDenied = 'AccessDenied'
    OperationNotPermitted = 'OperationNotPermitted'
    VpcIdNotFound = 'VpcIdNotFound'
    Unknown = 'Unknown'
    NodeCreationFailure = 'NodeCreationFailure'
    PodEvictionFailure = 'PodEvictionFailure'
    InsufficientFreeAddresses = 'InsufficientFreeAddresses'
    ClusterUnreachable = 'ClusterUnreachable'
    InsufficientNumberOfReplicas = 'InsufficientNumberOfReplicas'
    ConfigurationConflict = 'ConfigurationConflict'
    AdmissionRequestDenied = 'AdmissionRequestDenied'
    UnsupportedAddonModification = 'UnsupportedAddonModification'
    K8sResourceNotFound = 'K8sResourceNotFound'


class FargateProfileStatus(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    DELETING = 'DELETING'
    CREATE_FAILED = 'CREATE_FAILED'
    DELETE_FAILED = 'DELETE_FAILED'


class FargateProfilesRequestMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class InvalidParameterException(RootModel[Any]):
    root: Any


class InvalidRequestException(RootModel[Any]):
    root: Any


class IpFamily(Enum):
    ipv4 = 'ipv4'
    ipv6 = 'ipv6'


class ListAddonsRequest(BaseModel):
    pass


class ListAddonsRequestMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListClustersRequest(BaseModel):
    pass


class ListClustersRequestMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListFargateProfilesRequest(BaseModel):
    pass


class ListIdentityProviderConfigsRequest(BaseModel):
    pass


class ListIdentityProviderConfigsRequestMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListNodegroupsRequest(BaseModel):
    pass


class ListNodegroupsRequestMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListTagsForResourceRequest(BaseModel):
    pass


class ListUpdatesRequest(BaseModel):
    pass


class ListUpdatesRequestMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class LogType(Enum):
    api = 'api'
    audit = 'audit'
    authenticator = 'authenticator'
    controllerManager = 'controllerManager'
    scheduler = 'scheduler'


class LogTypes(RootModel[List[LogType]]):
    root: List[LogType]


class NodegroupIssueCode(Enum):
    AutoScalingGroupNotFound = 'AutoScalingGroupNotFound'
    AutoScalingGroupInvalidConfiguration = 'AutoScalingGroupInvalidConfiguration'
    Ec2SecurityGroupNotFound = 'Ec2SecurityGroupNotFound'
    Ec2SecurityGroupDeletionFailure = 'Ec2SecurityGroupDeletionFailure'
    Ec2LaunchTemplateNotFound = 'Ec2LaunchTemplateNotFound'
    Ec2LaunchTemplateVersionMismatch = 'Ec2LaunchTemplateVersionMismatch'
    Ec2SubnetNotFound = 'Ec2SubnetNotFound'
    Ec2SubnetInvalidConfiguration = 'Ec2SubnetInvalidConfiguration'
    IamInstanceProfileNotFound = 'IamInstanceProfileNotFound'
    IamLimitExceeded = 'IamLimitExceeded'
    IamNodeRoleNotFound = 'IamNodeRoleNotFound'
    NodeCreationFailure = 'NodeCreationFailure'
    AsgInstanceLaunchFailures = 'AsgInstanceLaunchFailures'
    InstanceLimitExceeded = 'InstanceLimitExceeded'
    InsufficientFreeAddresses = 'InsufficientFreeAddresses'
    AccessDenied = 'AccessDenied'
    InternalFailure = 'InternalFailure'
    ClusterUnreachable = 'ClusterUnreachable'
    Ec2SubnetMissingIpv6Assignment = 'Ec2SubnetMissingIpv6Assignment'


class NodegroupStatus(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    UPDATING = 'UPDATING'
    DELETING = 'DELETING'
    CREATE_FAILED = 'CREATE_FAILED'
    DELETE_FAILED = 'DELETE_FAILED'
    DEGRADED = 'DEGRADED'


class NonZeroInteger(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class NotFoundException(RootModel[Any]):
    root: Any


class PercentCapacity(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ResolveConflicts(Enum):
    OVERWRITE = 'OVERWRITE'
    NONE = 'NONE'
    PRESERVE = 'PRESERVE'


class ResourceInUseException(RootModel[Any]):
    root: Any


class ResourceLimitExceededException(RootModel[Any]):
    root: Any


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResourcePropagationDelayException(RootModel[Any]):
    root: Any


class RoleArn(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class ServerException(RootModel[Any]):
    root: Any


class ServiceUnavailableException(RootModel[Any]):
    root: Any


class String(RootModel[str]):
    root: str


class StringList(RootModel[List[String]]):
    root: List[String]


class TagKey(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class TagResourceResponse(BaseModel):
    pass


class TagValue(RootModel[constr(max_length=256)]):
    root: constr(max_length=256)


class TaintEffect(Enum):
    NO_SCHEDULE = 'NO_SCHEDULE'
    NO_EXECUTE = 'NO_EXECUTE'
    PREFER_NO_SCHEDULE = 'PREFER_NO_SCHEDULE'


class Timestamp(RootModel[datetime]):
    root: datetime


class UnsupportedAvailabilityZoneException(RootModel[Any]):
    root: Any


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResponse(BaseModel):
    pass


class UpdateAddonRequest(BaseModel):
    addonVersion: Optional[String] = None
    clientRequestToken: Optional[String] = None
    configurationValues: Optional[String] = None
    resolveConflicts: Optional[ResolveConflicts] = None
    serviceAccountRoleArn: Optional[RoleArn] = None


class UpdateClusterVersionRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    version: String


class UpdateParamType(Enum):
    Version = 'Version'
    PlatformVersion = 'PlatformVersion'
    EndpointPrivateAccess = 'EndpointPrivateAccess'
    EndpointPublicAccess = 'EndpointPublicAccess'
    ClusterLogging = 'ClusterLogging'
    DesiredSize = 'DesiredSize'
    LabelsToAdd = 'LabelsToAdd'
    LabelsToRemove = 'LabelsToRemove'
    TaintsToAdd = 'TaintsToAdd'
    TaintsToRemove = 'TaintsToRemove'
    MaxSize = 'MaxSize'
    MinSize = 'MinSize'
    ReleaseVersion = 'ReleaseVersion'
    PublicAccessCidrs = 'PublicAccessCidrs'
    LaunchTemplateName = 'LaunchTemplateName'
    LaunchTemplateVersion = 'LaunchTemplateVersion'
    IdentityProviderConfig = 'IdentityProviderConfig'
    EncryptionConfig = 'EncryptionConfig'
    AddonVersion = 'AddonVersion'
    ServiceAccountRoleArn = 'ServiceAccountRoleArn'
    ResolveConflicts = 'ResolveConflicts'
    MaxUnavailable = 'MaxUnavailable'
    MaxUnavailablePercentage = 'MaxUnavailablePercentage'


class UpdateStatus(Enum):
    InProgress = 'InProgress'
    Failed = 'Failed'
    Cancelled = 'Cancelled'
    Successful = 'Successful'


class UpdateType(Enum):
    VersionUpdate = 'VersionUpdate'
    EndpointAccessUpdate = 'EndpointAccessUpdate'
    LoggingUpdate = 'LoggingUpdate'
    ConfigUpdate = 'ConfigUpdate'
    AssociateIdentityProviderConfig = 'AssociateIdentityProviderConfig'
    DisassociateIdentityProviderConfig = 'DisassociateIdentityProviderConfig'
    AssociateEncryptionConfig = 'AssociateEncryptionConfig'
    AddonUpdate = 'AddonUpdate'


class VpcConfigRequest(BaseModel):
    endpointPrivateAccess: Optional[BoxedBoolean] = None
    endpointPublicAccess: Optional[BoxedBoolean] = None
    publicAccessCidrs: Optional[StringList] = None
    securityGroupIds: Optional[StringList] = None
    subnetIds: Optional[StringList] = None


class VpcConfigResponse(BaseModel):
    clusterSecurityGroupId: Optional[String] = None
    endpointPrivateAccess: Optional[Boolean] = None
    endpointPublicAccess: Optional[Boolean] = None
    publicAccessCidrs: Optional[StringList] = None
    securityGroupIds: Optional[StringList] = None
    subnetIds: Optional[StringList] = None
    vpcId: Optional[String] = None


class ZeroCapacity(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class ConfigStatus(Enum):
    CREATING = 'CREATING'
    DELETING = 'DELETING'
    ACTIVE = 'ACTIVE'


class LabelKey(RootModel[constr(min_length=1, max_length=63)]):
    root: constr(min_length=1, max_length=63)


class LabelValue(RootModel[constr(min_length=1, max_length=63)]):
    root: constr(min_length=1, max_length=63)


class LabelsKeyList(RootModel[List[String]]):
    root: List[String]


class LabelsMap(RootModel[Optional[Dict[str, LabelValue]]]):
    root: Optional[Dict[str, LabelValue]] = None


class RequiredClaimsKey(RootModel[constr(min_length=1, max_length=63)]):
    root: constr(min_length=1, max_length=63)


class RequiredClaimsValue(RootModel[constr(min_length=1, max_length=253)]):
    root: constr(min_length=1, max_length=253)


class TaintKey(RootModel[constr(min_length=1, max_length=63)]):
    root: constr(min_length=1, max_length=63)


class TaintValue(RootModel[constr(min_length=0, max_length=63)]):
    root: constr(min_length=0, max_length=63)


class Types(RootModel[List[String]]):
    root: List[String]


class Publishers(RootModel[List[String]]):
    root: List[String]


class Owners(RootModel[List[String]]):
    root: List[String]


class ConnectorConfig(BaseModel):
    provider: Optional[ConnectorConfigProvider] = None
    roleArn: Optional[String] = None


class ClusterRegistrationsPostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    connectorConfig: ConnectorConfig = Field(
        ..., description='The configuration sent to a cluster for configuration.'
    )
    name: constr(
        pattern=r'^[0-9A-Za-z][A-Za-z0-9\-_]*', min_length=1, max_length=100
    ) = Field(..., description='Define a unique name for this cluster for your Region.')
    tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The metadata that you apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Cluster tags do not propagate to any other resources associated with the cluster.',
    )


class Include(RootModel[List[String]]):
    root: List[String]


class KubernetesNetworkConfig(BaseModel):
    ipFamily: Optional[IpFamily] = None
    serviceIpv4Cidr: Optional[String] = None


class ResourcesVpcConfig(BaseModel):
    endpointPrivateAccess: Optional[BoxedBoolean] = None
    endpointPublicAccess: Optional[BoxedBoolean] = None
    publicAccessCidrs: Optional[StringList] = None
    securityGroupIds: Optional[StringList] = None
    subnetIds: Optional[StringList] = None


class ClustersNameAddonsPostRequest(BaseModel):
    addonName: str = Field(
        ...,
        description='The name of the add-on. The name must match one of the names that <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html"> <code>DescribeAddonVersions</code> </a> returns.',
    )
    addonVersion: Optional[str] = Field(
        None,
        description='The version of the add-on. The version must match one of the versions returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html"> <code>DescribeAddonVersions</code> </a>.',
    )
    clientRequestToken: Optional[str] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    configurationValues: Optional[str] = Field(
        None,
        description='The set of configuration values for the add-on that\'s created. The values that you provide are validated against the schema in <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonConfiguration.html"> <code>DescribeAddonConfiguration</code> </a>.',
    )
    resolveConflicts: Optional[ResolveConflicts] = Field(
        None,
        description='<p>How to resolve field value conflicts for an Amazon EKS add-on. Conflicts are handled based on the value you choose:</p> <ul> <li> <p> <b>None</b> – If the self-managed version of the add-on is installed on your cluster, Amazon EKS doesn\'t change the value. Creation of the add-on might fail.</p> </li> <li> <p> <b>Overwrite</b> – If the self-managed version of the add-on is installed on your cluster and the Amazon EKS default value is different than the existing value, Amazon EKS changes the value to the Amazon EKS default value.</p> </li> <li> <p> <b>Preserve</b> – Not supported. You can set this value when updating an add-on though. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html">UpdateAddon</a>.</p> </li> </ul> <p>If you don\'t currently have the self-managed version of the add-on installed on your cluster, the Amazon EKS add-on is installed. Amazon EKS sets all values to default values, regardless of the option that you specify.</p>',
    )
    serviceAccountRoleArn: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='<p>The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on\'s service account. The role must be assigned the IAM permissions required by the add-on. If you don\'t specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the <i>Amazon EKS User Guide</i>.</p> <note> <p>To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html">Enabling IAM roles for service accounts on your cluster</a> in the <i>Amazon EKS User Guide</i>.</p> </note>',
    )
    tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.',
    )


class ClustersNameAddonsAddonNameUpdatePostRequest(BaseModel):
    addonVersion: Optional[str] = Field(
        None,
        description='The version of the add-on. The version must match one of the versions returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html"> <code>DescribeAddonVersions</code> </a>.',
    )
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    configurationValues: Optional[str] = Field(
        None,
        description='The set of configuration values for the add-on that\'s created. The values that you provide are validated against the schema in <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonConfiguration.html">DescribeAddonConfiguration</a>.',
    )
    resolveConflicts: Optional[ResolveConflicts] = Field(
        None,
        description="<p>How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Conflicts are handled based on the option you choose:</p> <ul> <li> <p> <b>None</b> – Amazon EKS doesn't change the value. The update might fail.</p> </li> <li> <p> <b>Overwrite</b> – Amazon EKS overwrites the changed value back to the Amazon EKS default value.</p> </li> <li> <p> <b>Preserve</b> – Amazon EKS preserves the value. If you choose this option, we recommend that you test any field and value changes on a non-production cluster before updating the add-on on your production cluster.</p> </li> </ul>",
    )
    serviceAccountRoleArn: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='<p>The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on\'s service account. The role must be assigned the IAM permissions required by the add-on. If you don\'t specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the <i>Amazon EKS User Guide</i>.</p> <note> <p>To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html">Enabling IAM roles for service accounts on your cluster</a> in the <i>Amazon EKS User Guide</i>.</p> </note>',
    )


class IdentityProviderConfig1(BaseModel):
    name: Optional[String] = None
    type: Optional[String] = None


class ClustersNameIdentityProviderConfigsDescribePostRequest(BaseModel):
    identityProviderConfig: IdentityProviderConfig1 = Field(
        ..., description='An object representing an identity provider configuration.'
    )


class ClustersNameIdentityProviderConfigsDisassociatePostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    identityProviderConfig: IdentityProviderConfig1 = Field(
        ..., description='An object representing an identity provider configuration.'
    )


class AmiType(Enum):
    AL2_x86_64 = 'AL2_x86_64'
    AL2_x86_64_GPU = 'AL2_x86_64_GPU'
    AL2_ARM_64 = 'AL2_ARM_64'
    CUSTOM = 'CUSTOM'
    BOTTLEROCKET_ARM_64 = 'BOTTLEROCKET_ARM_64'
    BOTTLEROCKET_x86_64 = 'BOTTLEROCKET_x86_64'
    BOTTLEROCKET_ARM_64_NVIDIA = 'BOTTLEROCKET_ARM_64_NVIDIA'
    BOTTLEROCKET_x86_64_NVIDIA = 'BOTTLEROCKET_x86_64_NVIDIA'
    WINDOWS_CORE_2019_x86_64 = 'WINDOWS_CORE_2019_x86_64'
    WINDOWS_FULL_2019_x86_64 = 'WINDOWS_FULL_2019_x86_64'
    WINDOWS_CORE_2022_x86_64 = 'WINDOWS_CORE_2022_x86_64'
    WINDOWS_FULL_2022_x86_64 = 'WINDOWS_FULL_2022_x86_64'


class CapacityType(Enum):
    ON_DEMAND = 'ON_DEMAND'
    SPOT = 'SPOT'


class LaunchTemplate(BaseModel):
    id: Optional[String] = None
    name: Optional[String] = None
    version: Optional[String] = None


class RemoteAccess(BaseModel):
    ec2SshKey: Optional[String] = None
    sourceSecurityGroups: Optional[StringList] = None


class ScalingConfig(BaseModel):
    desiredSize: Optional[ZeroCapacity] = None
    maxSize: Optional[Capacity] = None
    minSize: Optional[ZeroCapacity] = None


class UpdateConfig(BaseModel):
    maxUnavailable: Optional[NonZeroInteger] = None
    maxUnavailablePercentage: Optional[PercentCapacity] = None


class Labels(BaseModel):
    addOrUpdateLabels: Optional[LabelsMap] = None
    removeLabels: Optional[LabelsKeyList] = None


class ClustersNameNodeGroupsNodegroupNameUpdateVersionPostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    force: Optional[bool] = Field(
        None,
        description="Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue. If an update fails because pods could not be drained, you can force the update after it fails to terminate the old node whether or not any pods are running on the node.",
    )
    launchTemplate: Optional[LaunchTemplate] = Field(
        None,
        description='<p>An object representing a node group launch template specification. The launch template can\'t include <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html"> <code>SubnetId</code> </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html"> <code>IamInstanceProfile</code> </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html"> <code>RequestSpotInstances</code> </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_HibernationOptionsRequest.html"> <code>HibernationOptions</code> </a>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TerminateInstances.html"> <code>TerminateInstances</code> </a>, or the node group deployment or update will fail. For more information about launch templates, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html"> <code>CreateLaunchTemplate</code> </a> in the Amazon EC2 API Reference. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p> <p>You must specify either the launch template ID or the launch template name in the request, but not both.</p>',
    )
    releaseVersion: Optional[str] = Field(
        None,
        description='<p>The AMI version of the Amazon EKS optimized AMI to use for the update. By default, the latest available AMI version for the node group\'s Kubernetes version is used. For information about Linux versions, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS optimized Amazon Linux AMI versions</a> in the <i>Amazon EKS User Guide</i>. Amazon EKS managed node groups support the November 2022 and later releases of the Windows AMIs. For information about Windows versions, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html">Amazon EKS optimized Windows AMI versions</a> in the <i>Amazon EKS User Guide</i>.</p> <p>If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don\'t specify <code>releaseVersion</code>, or the node group update will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>',
    )
    version: Optional[str] = Field(
        None,
        description='The Kubernetes version to update to. If no version is specified, then the Kubernetes version of the node group does not change. You can specify the Kubernetes version of the cluster to update the node group to the latest AMI version of the cluster\'s Kubernetes version. If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don\'t specify <code>version</code>, or the node group update will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.',
    )


class ClustersNameUpdatesPostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    version: str = Field(
        ..., description='The desired Kubernetes version following a successful update.'
    )


class TagsResourceArnPostRequest(BaseModel):
    tags: Dict[str, TagValue] = Field(
        ...,
        description='The tags to add to the resource. A tag is an array of key-value pairs.',
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class AddonIssue(BaseModel):
    code: Optional[AddonIssueCode] = None
    message: Optional[String] = None
    resourceIds: Optional[StringList] = None


class AddonIssueList(RootModel[List[AddonIssue]]):
    root: List[AddonIssue]


class AutoScalingGroup(BaseModel):
    name: Optional[String] = None


class AutoScalingGroupList(RootModel[List[AutoScalingGroup]]):
    root: List[AutoScalingGroup]


class Certificate(BaseModel):
    data: Optional[String] = None


class ClusterIssue(BaseModel):
    code: Optional[ClusterIssueCode] = None
    message: Optional[String] = None
    resourceIds: Optional[StringList] = None


class ClusterIssueList(RootModel[List[ClusterIssue]]):
    root: List[ClusterIssue]


class Compatibility(BaseModel):
    clusterVersion: Optional[String] = None
    defaultVersion: Optional[Boolean] = None
    platformVersions: Optional[StringList] = None


class ConnectorConfigRequest(BaseModel):
    provider: ConnectorConfigProvider
    roleArn: String


class ConnectorConfigResponse(BaseModel):
    activationCode: Optional[String] = None
    activationExpiry: Optional[Timestamp] = None
    activationId: Optional[String] = None
    provider: Optional[String] = None
    roleArn: Optional[String] = None


class ControlPlanePlacementRequest(BaseModel):
    groupName: Optional[String] = None


class ControlPlanePlacementResponse(BaseModel):
    groupName: Optional[String] = None


class DescribeAddonConfigurationResponse(BaseModel):
    addonName: Optional[String] = None
    addonVersion: Optional[String] = None
    configurationSchema: Optional[String] = None


class ErrorDetail(BaseModel):
    errorCode: Optional[ErrorCode] = None
    errorMessage: Optional[String] = None
    resourceIds: Optional[StringList] = None


class ErrorDetails(RootModel[List[ErrorDetail]]):
    root: List[ErrorDetail]


class FargateProfileLabel(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class FargateProfileSelector(BaseModel):
    labels: Optional[FargateProfileLabel] = None
    namespace: Optional[String] = None


class FargateProfileSelectors(RootModel[List[FargateProfileSelector]]):
    root: List[FargateProfileSelector]


class IdentityProviderConfig(BaseModel):
    name: String
    type: String


class IdentityProviderConfigs(RootModel[List[IdentityProviderConfig]]):
    root: List[IdentityProviderConfig]


class IncludeClustersList(RootModel[List[String]]):
    root: List[String]


class Issue(BaseModel):
    code: Optional[NodegroupIssueCode] = None
    message: Optional[String] = None
    resourceIds: Optional[StringList] = None


class IssueList(RootModel[List[Issue]]):
    root: List[Issue]


class KubernetesNetworkConfigRequest(BaseModel):
    ipFamily: Optional[IpFamily] = None
    serviceIpv4Cidr: Optional[String] = None


class KubernetesNetworkConfigResponse(BaseModel):
    ipFamily: Optional[IpFamily] = None
    serviceIpv4Cidr: Optional[String] = None
    serviceIpv6Cidr: Optional[String] = None


class LaunchTemplateSpecification(BaseModel):
    id: Optional[String] = None
    name: Optional[String] = None
    version: Optional[String] = None


class ListAddonsResponse(BaseModel):
    addons: Optional[StringList] = None
    nextToken: Optional[String] = None


class ListClustersResponse(BaseModel):
    clusters: Optional[StringList] = None
    nextToken: Optional[String] = None


class ListFargateProfilesResponse(BaseModel):
    fargateProfileNames: Optional[StringList] = None
    nextToken: Optional[String] = None


class ListIdentityProviderConfigsResponse(BaseModel):
    identityProviderConfigs: Optional[IdentityProviderConfigs] = None
    nextToken: Optional[String] = None


class ListNodegroupsResponse(BaseModel):
    nextToken: Optional[String] = None
    nodegroups: Optional[StringList] = None


class ListUpdatesResponse(BaseModel):
    nextToken: Optional[String] = None
    updateIds: Optional[StringList] = None


class LogSetup(BaseModel):
    enabled: Optional[BoxedBoolean] = None
    types: Optional[LogTypes] = None


class LogSetups(RootModel[List[LogSetup]]):
    root: List[LogSetup]


class Logging(BaseModel):
    clusterLogging: Optional[LogSetups] = None


class MarketplaceInformation(BaseModel):
    productId: Optional[String] = None
    productUrl: Optional[String] = None


class NodegroupHealth(BaseModel):
    issues: Optional[IssueList] = None


class NodegroupResources(BaseModel):
    autoScalingGroups: Optional[AutoScalingGroupList] = None
    remoteAccessSecurityGroup: Optional[String] = None


class NodegroupScalingConfig(BaseModel):
    desiredSize: Optional[ZeroCapacity] = None
    maxSize: Optional[Capacity] = None
    minSize: Optional[ZeroCapacity] = None


class NodegroupUpdateConfig(BaseModel):
    maxUnavailable: Optional[NonZeroInteger] = None
    maxUnavailablePercentage: Optional[PercentCapacity] = None


class OIDC(BaseModel):
    issuer: Optional[String] = None


class OutpostConfigRequest(BaseModel):
    controlPlaneInstanceType: String
    controlPlanePlacement: Optional[ControlPlanePlacementRequest] = None
    outpostArns: StringList


class OutpostConfigResponse(BaseModel):
    controlPlaneInstanceType: String
    controlPlanePlacement: Optional[ControlPlanePlacementResponse] = None
    outpostArns: StringList


class Provider(BaseModel):
    keyArn: Optional[String] = None


class RemoteAccessConfig(BaseModel):
    ec2SshKey: Optional[String] = None
    sourceSecurityGroups: Optional[StringList] = None


class TagMap(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class TagResourceRequest(BaseModel):
    tags: TagMap


class Taint(BaseModel):
    effect: Optional[TaintEffect] = None
    key: Optional[TaintKey] = None
    value: Optional[TaintValue] = None


class UpdateClusterConfigRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    logging: Optional[Logging] = None
    resourcesVpcConfig: Optional[VpcConfigRequest] = None


class UpdateLabelsPayload(BaseModel):
    addOrUpdateLabels: Optional[LabelsMap] = None
    removeLabels: Optional[LabelsKeyList] = None


class UpdateNodegroupVersionRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    force: Optional[Boolean] = None
    launchTemplate: Optional[LaunchTemplateSpecification] = None
    releaseVersion: Optional[String] = None
    version: Optional[String] = None


class UpdateParam(BaseModel):
    type: Optional[UpdateParamType] = None
    value: Optional[String] = None


class UpdateParams(RootModel[List[UpdateParam]]):
    root: List[UpdateParam]


class RequiredClaimsMap(RootModel[Optional[Dict[str, RequiredClaimsValue]]]):
    root: Optional[Dict[str, RequiredClaimsValue]] = None


class TaintsList(RootModel[List[Taint]]):
    root: List[Taint]


class OutpostConfig(BaseModel):
    controlPlaneInstanceType: Optional[String] = None
    controlPlanePlacement: Optional[ControlPlanePlacementRequest] = None
    outpostArns: Optional[StringList] = None


class ClustersNameFargateProfilesPostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    fargateProfileName: str = Field(..., description='The name of the Fargate profile.')
    podExecutionRoleArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod Execution Role</a> in the <i>Amazon EKS User Guide</i>.',
    )
    selectors: Optional[List[FargateProfileSelector]] = Field(
        None,
        description='The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. You may specify up to five selectors in a Fargate profile.',
    )
    subnets: Optional[List[String]] = Field(
        None,
        description='The IDs of subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are accepted for this parameter.',
    )
    tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The metadata to apply to the Fargate profile to assist with categorization and organization. Each tag consists of a key and an optional value. You define both. Fargate profile tags do not propagate to any other resources associated with the Fargate profile, such as the pods that are scheduled with it.',
    )


class Oidc(BaseModel):
    clientId: Optional[String] = None
    groupsClaim: Optional[String] = None
    groupsPrefix: Optional[String] = None
    identityProviderConfigName: Optional[String] = None
    issuerUrl: Optional[String] = None
    requiredClaims: Optional[RequiredClaimsMap] = None
    usernameClaim: Optional[String] = None
    usernamePrefix: Optional[String] = None


class ClustersNameIdentityProviderConfigsAssociatePostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    oidc: Oidc = Field(
        ...,
        description='An object representing an OpenID Connect (OIDC) configuration. Before associating an OIDC identity provider to your cluster, review the considerations in <a href="https://docs.aws.amazon.com/eks/latest/userguide/authenticate-oidc-identity-provider.html">Authenticating users for your cluster from an OpenID Connect identity provider</a> in the <i>Amazon EKS User Guide</i>.',
    )
    tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The metadata to apply to the configuration to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.',
    )


class ClustersNameNodeGroupsPostRequest(BaseModel):
    amiType: Optional[AmiType] = Field(
        None,
        description='The AMI type for your node group. If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don\'t specify <code>amiType</code>, or the node group deployment will fail. If your launch template uses a Windows custom AMI, then add <code>eks:kube-proxy-windows</code> to your Windows nodes <code>rolearn</code> in the <code>aws-auth</code> <code>ConfigMap</code>. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.',
    )
    capacityType: Optional[CapacityType] = Field(
        None, description='The capacity type for your node group.'
    )
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    diskSize: Optional[int] = Field(
        None,
        description='The root device disk size (in GiB) for your node group instances. The default disk size is 20 GiB for Linux and Bottlerocket. The default disk size is 50 GiB for Windows. If you specify <code>launchTemplate</code>, then don\'t specify <code>diskSize</code>, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.',
    )
    instanceTypes: Optional[List[String]] = Field(
        None,
        description='Specify the instance types for a node group. If you specify a GPU instance type, make sure to also specify an applicable GPU AMI type with the <code>amiType</code> parameter. If you specify <code>launchTemplate</code>, then you can specify zero or one instance type in your launch template <i>or</i> you can specify 0-20 instance types for <code>instanceTypes</code>. If however, you specify an instance type in your launch template <i>and</i> specify any <code>instanceTypes</code>, the node group deployment will fail. If you don\'t specify an instance type in a launch template or for <code>instanceTypes</code>, then <code>t3.medium</code> is used, by default. If you specify <code>Spot</code> for <code>capacityType</code>, then we recommend specifying multiple values for <code>instanceTypes</code>. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types">Managed node group capacity types</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.',
    )
    labels: Optional[Dict[str, LabelValue]] = Field(
        None,
        description='The Kubernetes labels to be applied to the nodes in the node group when they are created.',
    )
    launchTemplate: Optional[LaunchTemplate] = Field(
        None,
        description='<p>An object representing a node group launch template specification. The launch template can\'t include <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html"> <code>SubnetId</code> </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html"> <code>IamInstanceProfile</code> </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html"> <code>RequestSpotInstances</code> </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_HibernationOptionsRequest.html"> <code>HibernationOptions</code> </a>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TerminateInstances.html"> <code>TerminateInstances</code> </a>, or the node group deployment or update will fail. For more information about launch templates, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html"> <code>CreateLaunchTemplate</code> </a> in the Amazon EC2 API Reference. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p> <p>You must specify either the launch template ID or the launch template name in the request, but not both.</p>',
    )
    nodeRole: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the IAM role to associate with your node group. The Amazon EKS worker node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch nodes and register them into a cluster, you must create an IAM role for those nodes to use when they are launched. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the <i> <i>Amazon EKS User Guide</i> </i>. If you specify <code>launchTemplate</code>, then don\'t specify <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html"> <code>IamInstanceProfile</code> </a> in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.',
    )
    nodegroupName: str = Field(
        ..., description='The unique name to give your node group.'
    )
    releaseVersion: Optional[str] = Field(
        None,
        description='<p>The AMI version of the Amazon EKS optimized AMI to use with your node group. By default, the latest available AMI version for the node group\'s current Kubernetes version is used. For information about Linux versions, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS optimized Amazon Linux AMI versions</a> in the <i>Amazon EKS User Guide</i>. Amazon EKS managed node groups support the November 2022 and later releases of the Windows AMIs. For information about Windows versions, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html">Amazon EKS optimized Windows AMI versions</a> in the <i>Amazon EKS User Guide</i>.</p> <p>If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don\'t specify <code>releaseVersion</code>, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>',
    )
    remoteAccess: Optional[RemoteAccess] = Field(
        None,
        description='An object representing the remote access configuration for the managed node group.',
    )
    scalingConfig: Optional[ScalingConfig] = Field(
        None,
        description='An object representing the scaling configuration details for the Auto Scaling group that is associated with your node group. When creating a node group, you must specify all or none of the properties. When updating a node group, you can specify any or none of the properties.',
    )
    subnets: List[String] = Field(
        ...,
        description='The subnets to use for the Auto Scaling group that is created for your node group. If you specify <code>launchTemplate</code>, then don\'t specify <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html"> <code>SubnetId</code> </a> in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.',
    )
    tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value. You define both. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets.',
    )
    taints: Optional[List[Taint]] = Field(
        None,
        description='The Kubernetes taints to be applied to the nodes in the node group. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.',
    )
    updateConfig: Optional[UpdateConfig] = Field(
        None, description='The node group update configuration.'
    )
    version: Optional[str] = Field(
        None,
        description='The Kubernetes version to use for your managed nodes. By default, the Kubernetes version of the cluster is used, and this is the only accepted specified value. If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don\'t specify <code>version</code>, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.',
    )


class Taints(BaseModel):
    addOrUpdateTaints: Optional[TaintsList] = None
    removeTaints: Optional[TaintsList] = None


class ClustersNameNodeGroupsNodegroupNameUpdateConfigPostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    labels: Optional[Labels] = Field(
        None,
        description='An object representing a Kubernetes label change for a managed node group.',
    )
    scalingConfig: Optional[ScalingConfig] = Field(
        None,
        description='An object representing the scaling configuration details for the Auto Scaling group that is associated with your node group. When creating a node group, you must specify all or none of the properties. When updating a node group, you can specify any or none of the properties.',
    )
    taints: Optional[Taints] = Field(
        None,
        description='An object representing the details of an update to a taints payload. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.',
    )
    updateConfig: Optional[UpdateConfig] = Field(
        None, description='The node group update configuration.'
    )


class ClustersNameUpdateConfigPostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    logging: Optional[Logging] = Field(
        None,
        description='An object representing the logging configuration for resources in your cluster.',
    )
    resourcesVpcConfig: Optional[ResourcesVpcConfig] = Field(
        None,
        description='An object representing the VPC configuration to use for an Amazon EKS cluster.',
    )


class AddonHealth(BaseModel):
    issues: Optional[AddonIssueList] = None


class ClusterHealth(BaseModel):
    issues: Optional[ClusterIssueList] = None


class Compatibilities(RootModel[List[Compatibility]]):
    root: List[Compatibility]


class CreateAddonRequest(BaseModel):
    addonName: String
    addonVersion: Optional[String] = None
    clientRequestToken: Optional[String] = None
    configurationValues: Optional[String] = None
    resolveConflicts: Optional[ResolveConflicts] = None
    serviceAccountRoleArn: Optional[RoleArn] = None
    tags: Optional[TagMap] = None


class CreateFargateProfileRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    fargateProfileName: String
    podExecutionRoleArn: String
    selectors: Optional[FargateProfileSelectors] = None
    subnets: Optional[StringList] = None
    tags: Optional[TagMap] = None


class CreateNodegroupRequest(BaseModel):
    amiType: Optional[AMITypes] = None
    capacityType: Optional[CapacityTypes] = None
    clientRequestToken: Optional[String] = None
    diskSize: Optional[BoxedInteger] = None
    instanceTypes: Optional[StringList] = None
    labels: Optional[LabelsMap] = None
    launchTemplate: Optional[LaunchTemplateSpecification] = None
    nodeRole: String
    nodegroupName: String
    releaseVersion: Optional[String] = None
    remoteAccess: Optional[RemoteAccessConfig] = None
    scalingConfig: Optional[NodegroupScalingConfig] = None
    subnets: StringList
    tags: Optional[TagMap] = None
    taints: Optional[TaintsList] = None
    updateConfig: Optional[NodegroupUpdateConfig] = None
    version: Optional[String] = None


class DescribeIdentityProviderConfigRequest(BaseModel):
    identityProviderConfig: IdentityProviderConfig


class DisassociateIdentityProviderConfigRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    identityProviderConfig: IdentityProviderConfig


class EncryptionConfig(BaseModel):
    provider: Optional[Provider] = None
    resources: Optional[StringList] = None


class EncryptionConfigList(RootModel[List[EncryptionConfig]]):
    root: List[EncryptionConfig] = Field(..., max_length=1)


class FargateProfile(BaseModel):
    clusterName: Optional[String] = None
    createdAt: Optional[Timestamp] = None
    fargateProfileArn: Optional[String] = None
    fargateProfileName: Optional[String] = None
    podExecutionRoleArn: Optional[String] = None
    selectors: Optional[FargateProfileSelectors] = None
    status: Optional[FargateProfileStatus] = None
    subnets: Optional[StringList] = None
    tags: Optional[TagMap] = None


class Identity(BaseModel):
    oidc: Optional[OIDC] = None


class ListTagsForResourceResponse(BaseModel):
    tags: Optional[TagMap] = None


class Nodegroup(BaseModel):
    amiType: Optional[AMITypes] = None
    capacityType: Optional[CapacityTypes] = None
    clusterName: Optional[String] = None
    createdAt: Optional[Timestamp] = None
    diskSize: Optional[BoxedInteger] = None
    health: Optional[NodegroupHealth] = None
    instanceTypes: Optional[StringList] = None
    labels: Optional[LabelsMap] = None
    launchTemplate: Optional[LaunchTemplateSpecification] = None
    modifiedAt: Optional[Timestamp] = None
    nodeRole: Optional[String] = None
    nodegroupArn: Optional[String] = None
    nodegroupName: Optional[String] = None
    releaseVersion: Optional[String] = None
    remoteAccess: Optional[RemoteAccessConfig] = None
    resources: Optional[NodegroupResources] = None
    scalingConfig: Optional[NodegroupScalingConfig] = None
    status: Optional[NodegroupStatus] = None
    subnets: Optional[StringList] = None
    tags: Optional[TagMap] = None
    taints: Optional[TaintsList] = None
    updateConfig: Optional[NodegroupUpdateConfig] = None
    version: Optional[String] = None


class OidcIdentityProviderConfig(BaseModel):
    clientId: Optional[String] = None
    clusterName: Optional[String] = None
    groupsClaim: Optional[String] = None
    groupsPrefix: Optional[String] = None
    identityProviderConfigArn: Optional[String] = None
    identityProviderConfigName: Optional[String] = None
    issuerUrl: Optional[String] = None
    requiredClaims: Optional[RequiredClaimsMap] = None
    status: Optional[ConfigStatus] = None
    tags: Optional[TagMap] = None
    usernameClaim: Optional[String] = None
    usernamePrefix: Optional[String] = None


class OidcIdentityProviderConfigRequest(BaseModel):
    clientId: String
    groupsClaim: Optional[String] = None
    groupsPrefix: Optional[String] = None
    identityProviderConfigName: String
    issuerUrl: String
    requiredClaims: Optional[RequiredClaimsMap] = None
    usernameClaim: Optional[String] = None
    usernamePrefix: Optional[String] = None


class RegisterClusterRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    connectorConfig: ConnectorConfigRequest
    name: ClusterName
    tags: Optional[TagMap] = None


class Update(BaseModel):
    createdAt: Optional[Timestamp] = None
    errors: Optional[ErrorDetails] = None
    id: Optional[String] = None
    params: Optional[UpdateParams] = None
    status: Optional[UpdateStatus] = None
    type: Optional[UpdateType] = None


class UpdateAddonResponse(BaseModel):
    update: Optional[Update] = None


class UpdateClusterConfigResponse(BaseModel):
    update: Optional[Update] = None


class UpdateClusterVersionResponse(BaseModel):
    update: Optional[Update] = None


class UpdateNodegroupConfigResponse(BaseModel):
    update: Optional[Update] = None


class UpdateNodegroupVersionResponse(BaseModel):
    update: Optional[Update] = None


class UpdateTaintsPayload(BaseModel):
    addOrUpdateTaints: Optional[TaintsList] = None
    removeTaints: Optional[TaintsList] = None


class ClustersPostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.',
    )
    encryptionConfig: Optional[List[EncryptionConfig]] = Field(
        None, description='The encryption configuration for the cluster.', max_length=1
    )
    kubernetesNetworkConfig: Optional[KubernetesNetworkConfig] = Field(
        None, description='The Kubernetes network configuration for the cluster.'
    )
    logging: Optional[Logging] = Field(
        None,
        description='An object representing the logging configuration for resources in your cluster.',
    )
    name: constr(
        pattern=r'^[0-9A-Za-z][A-Za-z0-9\-_]*', min_length=1, max_length=100
    ) = Field(..., description='The unique name to give to your cluster.')
    outpostConfig: Optional[OutpostConfig] = Field(
        None,
        description='The configuration of your local Amazon EKS cluster on an Amazon Web Services Outpost. Before creating a cluster on an Outpost, review <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-local-cluster-create.html">Creating a local cluster on an Outpost</a> in the <i>Amazon EKS User Guide</i>. This API isn\'t available for Amazon EKS clusters on the Amazon Web Services cloud.',
    )
    resourcesVpcConfig: ResourcesVpcConfig = Field(
        ...,
        description='An object representing the VPC configuration to use for an Amazon EKS cluster.',
    )
    roleArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control plane to make calls to Amazon Web Services API operations on your behalf. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html">Amazon EKS Service IAM Role</a> in the <i> <i>Amazon EKS User Guide</i> </i>.',
    )
    tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.',
    )
    version: Optional[str] = Field(
        None,
        description="<p>The desired Kubernetes version for your cluster. If you don't specify a value here, the default version available in Amazon EKS is used.</p> <note> <p>The default version might not be the latest version available.</p> </note>",
    )


class ClustersNameEncryptionConfigAssociatePostRequest(BaseModel):
    clientRequestToken: Optional[str] = Field(
        None,
        description='The client request token you are using with the encryption configuration.',
    )
    encryptionConfig: List[EncryptionConfig] = Field(
        ..., description='The configuration you are using for encryption.', max_length=1
    )


class Addon(BaseModel):
    addonArn: Optional[String] = None
    addonName: Optional[String] = None
    addonVersion: Optional[String] = None
    clusterName: Optional[ClusterName] = None
    configurationValues: Optional[String] = None
    createdAt: Optional[Timestamp] = None
    health: Optional[AddonHealth] = None
    marketplaceInformation: Optional[MarketplaceInformation] = None
    modifiedAt: Optional[Timestamp] = None
    owner: Optional[String] = None
    publisher: Optional[String] = None
    serviceAccountRoleArn: Optional[String] = None
    status: Optional[AddonStatus] = None
    tags: Optional[TagMap] = None


class AddonVersionInfo(BaseModel):
    addonVersion: Optional[String] = None
    architecture: Optional[StringList] = None
    compatibilities: Optional[Compatibilities] = None
    requiresConfiguration: Optional[Boolean] = None


class AddonVersionInfoList(RootModel[List[AddonVersionInfo]]):
    root: List[AddonVersionInfo]


class AssociateEncryptionConfigRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    encryptionConfig: EncryptionConfigList


class AssociateEncryptionConfigResponse(BaseModel):
    update: Optional[Update] = None


class AssociateIdentityProviderConfigRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    oidc: OidcIdentityProviderConfigRequest
    tags: Optional[TagMap] = None


class AssociateIdentityProviderConfigResponse(BaseModel):
    tags: Optional[TagMap] = None
    update: Optional[Update] = None


class Cluster(BaseModel):
    arn: Optional[String] = None
    certificateAuthority: Optional[Certificate] = None
    clientRequestToken: Optional[String] = None
    connectorConfig: Optional[ConnectorConfigResponse] = None
    createdAt: Optional[Timestamp] = None
    encryptionConfig: Optional[EncryptionConfigList] = None
    endpoint: Optional[String] = None
    health: Optional[ClusterHealth] = None
    id: Optional[String] = None
    identity: Optional[Identity] = None
    kubernetesNetworkConfig: Optional[KubernetesNetworkConfigResponse] = None
    logging: Optional[Logging] = None
    name: Optional[String] = None
    outpostConfig: Optional[OutpostConfigResponse] = None
    platformVersion: Optional[String] = None
    resourcesVpcConfig: Optional[VpcConfigResponse] = None
    roleArn: Optional[String] = None
    status: Optional[ClusterStatus] = None
    tags: Optional[TagMap] = None
    version: Optional[String] = None


class CreateAddonResponse(BaseModel):
    addon: Optional[Addon] = None


class CreateClusterRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    encryptionConfig: Optional[EncryptionConfigList] = None
    kubernetesNetworkConfig: Optional[KubernetesNetworkConfigRequest] = None
    logging: Optional[Logging] = None
    name: ClusterName
    outpostConfig: Optional[OutpostConfigRequest] = None
    resourcesVpcConfig: VpcConfigRequest
    roleArn: String
    tags: Optional[TagMap] = None
    version: Optional[String] = None


class CreateClusterResponse(BaseModel):
    cluster: Optional[Cluster] = None


class CreateFargateProfileResponse(BaseModel):
    fargateProfile: Optional[FargateProfile] = None


class CreateNodegroupResponse(BaseModel):
    nodegroup: Optional[Nodegroup] = None


class DeleteAddonResponse(BaseModel):
    addon: Optional[Addon] = None


class DeleteClusterResponse(BaseModel):
    cluster: Optional[Cluster] = None


class DeleteFargateProfileResponse(BaseModel):
    fargateProfile: Optional[FargateProfile] = None


class DeleteNodegroupResponse(BaseModel):
    nodegroup: Optional[Nodegroup] = None


class DeregisterClusterResponse(BaseModel):
    cluster: Optional[Cluster] = None


class DescribeAddonResponse(BaseModel):
    addon: Optional[Addon] = None


class DescribeClusterResponse(BaseModel):
    cluster: Optional[Cluster] = None


class DescribeFargateProfileResponse(BaseModel):
    fargateProfile: Optional[FargateProfile] = None


class DescribeNodegroupResponse(BaseModel):
    nodegroup: Optional[Nodegroup] = None


class DescribeUpdateResponse(BaseModel):
    update: Optional[Update] = None


class DisassociateIdentityProviderConfigResponse(BaseModel):
    update: Optional[Update] = None


class IdentityProviderConfigResponse(BaseModel):
    oidc: Optional[OidcIdentityProviderConfig] = None


class RegisterClusterResponse(BaseModel):
    cluster: Optional[Cluster] = None


class UpdateNodegroupConfigRequest(BaseModel):
    clientRequestToken: Optional[String] = None
    labels: Optional[UpdateLabelsPayload] = None
    scalingConfig: Optional[NodegroupScalingConfig] = None
    taints: Optional[UpdateTaintsPayload] = None
    updateConfig: Optional[NodegroupUpdateConfig] = None


class AddonInfo(BaseModel):
    addonName: Optional[String] = None
    addonVersions: Optional[AddonVersionInfoList] = None
    marketplaceInformation: Optional[MarketplaceInformation] = None
    owner: Optional[String] = None
    publisher: Optional[String] = None
    type: Optional[String] = None


class Addons(RootModel[List[AddonInfo]]):
    root: List[AddonInfo]


class DescribeAddonVersionsResponse(BaseModel):
    addons: Optional[Addons] = None
    nextToken: Optional[String] = None


class DescribeIdentityProviderConfigResponse(BaseModel):
    identityProviderConfig: Optional[IdentityProviderConfigResponse] = None
